This is a mesh of bib file and markdown file that I use for my own records.

This file contains papers related to NVM programming and storage models.

Papers marked with (*) are from (or co-authored by somebody from) Synch group at
URCS.

# Starting points:
```bibtex
@article{rudoff-login-2017,
  title={Persistent memory programming},
  author={Rudoff, Andy},
  journal={Login: The Usenix Magazine},
  volume={42},
  pages={34--40},
  year={2017}
}
```

# Persistence theory:

### Durable Linearizability (*):
```bibtex
@inproceedings{izraelevitz-disc-2016,
  title={Linearizability of persistent memory objects under a full-system-crash failure model},
  author={Izraelevitz, Joseph and Mendes, Hammurabi and Scott, Michael L},
  booktitle={International Symposium on Distributed Computing},
  pages={313--327},
  year={2016},
  organization={Springer},
  address={Paris, France}
}
​```location

### Nesting-safe recoverable linearizability:
​```bibtex
@inproceedings{attiya-podc-2018,
  title={Nesting-safe recoverable linearizability: Modular constructions for non-volatile memory},
  author={Attiya, Hagit and Ben-Baruch, Ohad and Hendler, Danny},
  booktitle={Proceedings of the 2018 ACM Symposium on Principles of Distributed Computing},
  pages={7--16},
  year={2018},
  organization={ACM},
  address={Egham, United Kindom}
}
```

# NVM Programming models:

## Legacy persistent programming:

### Unifying persistent and transient views of data:
```bibtex
@article{atkinson-journal-1983,
  title={An approach to persistent programming},
  author={Atkinson, Malcolm P. and Bailey, Peter J. and Chisholm, Ken J and Cockshott, Paul W and Morrison, Ronald},
  journal={The computer journal},
  volume={26},
  number={4},
  pages={360--365},
  year={1983},
  publisher={The British Computer Society}
}
```

### orthogonally persistent object systems
```bibtex
@article{atkinson-vldb-1995,
  title={Orthogonally persistent object systems},
  author={Atkinson, Malcolm and Morrison, Ronald},
  journal={The VLDB Journal—The International Journal on Very Large Data Bases},
  volume={4},
  number={3},
  pages={319--402},
  year={1995},
  publisher={Springer-Verlag New York, Inc.},
  address={Zurich, Switzerland}
}
```

### mostly-copying orthogonal persistence
```bibtex
@inproceedings{hosking-oopsla-1999,
 author = {Hosking, Antony L. and Chen, Jiawan},
 title = {Mostly-copying Reachability-based Orthogonal Persistence},
 booktitle = {Proceedings of the 14th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications},
 series = {OOPSLA '99},
 year = {1999},
 address = {Denver, Colorado, USA},
 pages = {382--398},
 numpages = {17},
} 
```

### ObjectStore
```bibtex
@article{lamb-1991,
  title={The ObjectStore database system},
  author={Lamb, Charles and Landis, Gordon and Orenstein, Jack and Weinreb, Dan},
  journal={Communications of the ACM},
  volume={34},
  number={10},
  pages={50--63},
  year={1991},
  publisher={ACM}
}
```

### commercial object-oriented database management systems
```bibtex
@article{soloviev-1992,
  title={An overview of three commercial object-oriented database management systems: ONTOS, ObjectStore, and O 2},
  author={Soloviev, Valery},
  journal={ACM SIGMOD Record},
  volume={21},
  number={1},
  pages={93--104},
  year={1992},
  publisher={ACM}
}
```

### Pointer switzzling
```bibtex
@article{wilson-ooos-1991,
  title={Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware},
  author={Wilson, Paul R},
  journal={ACM SIGARCH Computer Architecture News},
  volume={19},
  number={4},
  pages={6--13},
  year={1991},
  publisher={ACM}
}
```

### Pointer switzzling techniques
```bibtex
@article{kemper-journal-1995,
 author = {Kemper, Alfons and Kossmann, Donald},
 title = {Adaptable Pointer Swizzling Strategies in Object Bases: Design, Realization, and Quantitative Analysis},
 journal = {The VLDB Journal},
 issue_date = {July 1995},
 volume = {4},
 number = {3},
 month = jul,
 year = {1995},
 pages = {519--567},
 numpages = {49},
 publisher = {Springer-Verlag New York, Inc.},
 address = {Secaucus, NJ, USA},
 keywords = {object-oriented database systems, performance evaluation, pointer swizzling},
} 

```

## Lock-based systems:

### Atlas
* Failure & restart model:
  * persistent region with persistent root(s)
  * data is persistent if it's visible to _restart code_
* Sequenced before, synchronized with and happens-before
* FASE:
  * memory operations are sequenced and consecutive
  * a lock is held during FASE
  * immediately before/after the first/last memory operation of a FASE, no lock
    is held
* Durability order
  * $f_1 \leq_d f_2$ if $\exists$ unlock operation $X\in f_1$ and lock operation
    $Y \in f_2$ where $X <_{hb} Y$
  * if $f_1 \leq_d f_2$, $f_2$ is durable $\Rightarrow$ $f_1$ is durable.
  * individual stores before a FASE are durable only if this FASE is durable.
* Implementation details:
  * instrumented stores attach new store logs to the end of the log for each
    thread
  * the helper thread grabs log entries from the top of each thread, find out
    finished FASEs, build the durability order graph and remove both unfinished
    FASEs and FASEs depending on those unfinished FASEs. Then for each FASE in
    the graph, remove the corresponding entries from the log.
* Optimizations:
  * Log elision: some stores outside of FASE need not to be undone.
  * Do not issue flushes after _every_ store.
  * Leverage the log insert/prune pattern and use circular-buffer-based memory
    allocation
  * Try to combine flushes of log entries in the same cache line
* Minor issues:
  * requirement 1: shouldn't `ready` be persistent?
  * What's actually happening about log elision?
```bibtex
@inproceedings{chakrabarti-oopsla-2014,
 author = {Chakrabarti, Dhruva R. and Boehm, Hans-J. and Bhandari, Kumud},
 title = {Atlas: Leveraging Locks for Non-volatile Memory Consistency},
 booktitle = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
 series = {OOPSLA '14},
 year = {2014},
 address = {Portland, Oregon, USA},
 pages = {433--452},
 numpages = {20},
 publisher = {ACM},
} 
```

### JustDo (*)
* key idea: keep log of every persistent stores before it in every FASE. Upon crash, continue from the store to the end.
  * Assumption: caches are non-volatile
  * details:
    * lock intension logs to mark the necessity of recovering locks
```bibtex
@inproceedings{izraelevitz-asplos-2014,
 author = {Izraelevitz, Joseph and Kelly, Terence and Kolli, Aasheesh},
 title = {Failure-Atomic Persistent Memory Updates via JUSTDO Logging},
 booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '16},
 year = {2016},
 address = {Atlanta, Georgia, USA},
 numpages = {16},
 publisher = {ACM},
} 
```

### iDo (*)
```bibtex
@inproceedings{liu-micro-2018,
  title={iDO: Compiler-directed failure atomicity for nonvolatile memory},
  author={Liu, Qingrui and Izraelevitz, Joseph and Lee, Se Kwon and Scott, Michael L and Noh, Sam H and Jung, Changhee},
  booktitle={2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},
  pages={258--270},
  year={2018},
  organization={IEEE},
  address={Fukuoka, Japan}
}
```

## Transaction-based systems:

### Mnemosyne
* Persistent regions: only a portion of memory is persistent.
    * records the virtual-physical mapping of persistent regions
    * SCM pages are swapped to backing files so multiple applications can share
      access to them.
    * pages are mapped using *pmap*, and pointers pointing to persistent regions
      are labeled *persistent*
* Consistency
    * Single (atomic) variable update
    * Append updates: useful for logs
    * shadow updates
        * references can only be modified after new data has completed writing
        * best for trees - atomic by modifying a single pointer
    * In-place updates with transactions
* Durable memory transactions
    * transaction system:
        * write-ahead redo logging: less ordering constraints on writes, commits
          and reads are slower.
            * logs only writes to persistent regions
            * new values and address are written in the log and buffered in
              vol-memory
            * log is flushed on commitment. value is optional
        * encounter-time locking: for conflict detection
            * an array of locks in volatile memory, each covers a portion of
              addr space
            * transaction continues by trying to grab a lock.
            * if fails, abort the transaction and start over.
```bibtex
@inproceedings{volos-asplos-2011,
 author = {Volos, Haris and Tack, Andres Jaan and Swift, Michael M.},
 title = {Mnemosyne: Lightweight Persistent Memory},
 booktitle = {Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS XVI},
 year = {2011},
 address = {Newport Beach, California, USA},
 pages = {91--104},
 numpages = {14},
 publisher = {ACM},
} 

```

### PMDK
```bibtex
@misc{rudoff-pmdk-2014,
 author         = {Andy Rudoff
                and Marcin Slusarz},
 year           = {2014},
 month          = sep,
 title          = {Persistent Memory Development Kit},
 note           = {\url{pmem.io/pmdk/}},
 lastaccessed   = {April 4, 2019},
}
```

### QSTM (*)
```bibtex
@techreport{beadle-qstm-2019,
 author         = {H. Alan Beadle 
                and Wentao Cai 
                and Haosen Wen
                and Michael L. Scott},
 institution    = {Department of Computer Science, University of Rochester},
 month          = apr,
 number         = {TR 1006},
 title          = {Towards Efficient Nonblocking Persistent Software Transactional Memory},
 year           = {2019},
}
```

### Pisces: NVM Transactional Memory
* Problem: In current PTMs, reads suffer from persistency overhead and
  read-indirection overhead.
* Key idea: Use dual-version concurrency control instead of multi-version to
  reduce read-indirection overhead; Decouple persistency, committing and
  writeback phases to take write accesses to NVM and write blocking off the
  critical path.
* Details:
    * The system maintains a global timestamp. A read return a version when its
      tx timestamp is no smaller than the version timestamp of a block; Commit
      record the current global timestamp as its end timestamp and increase
      (blocking) the global timestamp; Writebacks of a tx will wait until all
      other tx begin timestamp go pass its end timestamp (grace period).
    * Tm-write acquires per-object lock. It uses the "next" pointer field as
      lock.
    * Reads are only blocked when the owner Tx of some object is updating its
      end timestamp and global timestamp. This is marked by "inCritical" flag.
* Other notes:
    * SI is not practical for all applications.
    * Write skew is a main drawback.
```bibtex
@inproceedings{gu-atc-2019,
  title={Pisces: A Scalable and Efficient Persistent Transactional Memory},
  author={Gu, Jinyu and Yu, Qianqian and Wang, Xiayang and Wang, Zhaoguo and Zang, Binyu and Guan, Haibing and Chen, Haibo},
  booktitle={2019 $\{$USENIX$\}$ Annual Technical Conference ($\{$USENIX$\}$$\{$ATC$\}$ 19)},
  pages={913--928},
  year={2019}
}
```

### OneFile
```bibtex
@inproceedings{ramalhete-dsn-2019,
  title={OneFile: A Wait-Free Persistent Transactional Memory},
  author={Ramalhete, Pedro and Correia, Andreia and Felber, Pascal and Cohen, Nachshon},
  booktitle={2019 49th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
  pages={151--163},
  year={2019},
  organization={IEEE},
  address={Portland, OR, USA}
}
```

### PMCAS
```bibtex
@inproceedings{pavlovic-podc-2018,
  title={Brief announcement: Persistent multi-word compare-and-swap},
  author={Pavlovic, Matej and Kogan, Alex and Marathe, Virendra J and Harris, Tim},
  booktitle={Proceedings of the 2018 ACM Symposium on Principles of Distributed Computing},
  pages={37--39},
  year={2018},
  organization={ACM},
  address={Egham, United Kindom}
}
```

### Romulus
```bibtex
@inproceedings{correia-spaa-2018,
  title={Romulus: Efficient algorithms for persistent transactional memory},
  author={Correia, Andreia and Felber, Pascal and Ramalhete, Pedro},
  booktitle={Proceedings of the 30th on Symposium on Parallelism in Algorithms and Architectures},
  pages={271--282},
  year={2018},
  organization={ACM},
  address={Vienna, Austria}
}
```

### Pangolin
```bibtex
@inproceedings{zhang-atc-2019,
  title={Pangolin: A Fault-Tolerant Persistent Memory Programming Library},
  author={Zhang, Lu and Swanson, Steven},
  booktitle={2019 USENIX Annual Technical Conference 19)},
  year={2019},
  address={Renton, WA, USA}
}
```

### Transforming STM into PTM
```bibtex
@inproceedings{zardoshti-pact-2019,
  title={Optimizing Persistent Memory Transactions},
  author={Zardoshti, Pantea and Zhou, Tingzhe and Liu, Yujie and Spear, Michael},
  booktitle={2019 28th International Conference on Parallel Architectures and Compilation Techniques (PACT)},
  pages={219--231},
  year={2019},
  organization={IEEE},
  address={Seattle, WA, USA}
}
```

### remove persistence dependencies in non-volatile transactions
```bibtex
@inproceedings{kolli-asplos-2016,
 author = {Kolli, Aasheesh and Pelley, Steven and Saidi, Ali and Chen, Peter M. and Wenisch, Thomas F.},
 title = {High-Performance Transactions for Persistent Memories},
 booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '16},
 year = {2016},
 address = {Atlanta, Georgia, USA},
 numpages = {13},
 publisher = {ACM},
}
```

### DudeTM
```bibtex
@inproceedings{liu-asplos-2017,
 author = {Liu, Mengxing and Zhang, Mingxing and Chen, Kang and Qian, Xuehai and Wu, Yongwei and Zheng, Weimin and Ren, Jinglei},
 title = {DudeTM: Building Durable Transactions with Decoupling for Persistent Memory},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '17},
 year = {2017},
 address = {Xi'an, China},
 pages = {329--343},
 numpages = {15},
 publisher = {ACM},
}
```

## Others & Utils:

### Refined NVM logging using validity bits
* Problem: Decide which entry is valid on NVM after a crash, given arbitrary
  crashes that invalidates cache contents; Each write to NVM log entry usually
  take 2 roundtrips to NVM.
* Key idea: The last store to a cache line is sent to memory no earlier than
  previous stores to the same cache line. If we can determine that the last
  store to a cache line $c$ is persisted, then cache line $c$ is persisted.
* Details:
    * The "last store" is store(s) to validity bit(s). 
        * CSO-VB (data fits in a single cache line): When the payload has bits
          to spare as validity bits (VB), we update those bits right before
          flush and fence for each cache line. The current "meaning" of VB is
          indicated by some bit in head pointer and flipped when entries are
          reused, which is natural in circular logs.
        * CSO-Random (data can be consecutive): Initialize the memory with a
          64-bit random value $r$, and the difference between real data and $r$
          at the last words of each cache line indicates validity.
        * CSO-FVB (flexible validity bit): Read the original value $v_0$ of the
          memory allocated for the data. For each word $w_0$ in $v_0$, find its
          last different bit from the corresponding word $w$ in new data and use
          it as validity bit. Put the location of the bit in a separate metadata
          field in the front of the entry. Use an additional validity bit to
          validate the metadata itself.
* Other notes:
    * No explicit synchronization provided. Good reference for thread-local
      structures.
    * This algorithm fits consecutive logs better. Pointer-rich logs (like
      DCAS-style TMs) might naturally need only one roundtrip to NVM to persist
      a write. Need further discussion.
```bibtex
@article{cohen-oopsla-2017,
  title={Efficient logging in non-volatile memory by exploiting coherency protocols},
  author={Cohen, Nachshon and Friedman, Michal and Larus, James R},
  journal={Proceedings of the ACM on Programming Languages},
  volume={1},
  number={OOPSLA},
  pages={67},
  year={2017},
  publisher={ACM},
  address={Vancouver, Canada}
}
```

### Failure-atomic msync()
* Problem: failure-atomic updates to non-volatile storage in batches.
* Details:
    * Semantics:
        * MS_ASYNC: define and enqueue atomic update without waiting for
          completion
        * MS_INVALIDATE: roll back to the last MS_ASYNC
    * Challenges:
        * Existing write back functions of ext4 create a separate handle for
          each dirty page in a ext4_writepage() call, while JDB2, the journal
          underneath ext4, only ensures atomicity in per-handle granularity.
          Their implementation make sure that all writebacks of an msync() are
          packed in a single handle.
        * Ensure modified pages are not written back until an msync(), even if
          memory pressure arises. The OS can write dirty pages to temporary
          durable storage and swap them in on msync.
* Notes:
    * Msync requires OS support
    * It only provides failure atomicity in msynch-granularity, leaving
      synchronization to the application.
```bibtex
@inproceedings{park-eurosys-2013,
 author = {Park, Stan and Kelly, Terence and Shen, Kai},
 title = {Failure-atomic Msync(): A Simple and Efficient Mechanism for Preserving the Integrity of Durable Data},
 booktitle = {Proceedings of the 8th ACM European Conference on Computer Systems},
 series = {EuroSys '13},
 year = {2013},
 address = {Prague, Czech Republic},
 pages = {225--238},
 numpages = {14},
 publisher = {ACM},
} 
```

### In-place update of persistent blocks
* key idea: keep replica(s) for backup. Do updates in-place and copy the update
  to replica at commit time before releasing the lock.
```bibtex
@inproceedings{memaripour-eurosys-2017,
  title={Atomic in-place updates for non-volatile main memories with kamino-tx},
  author={Memaripour, Amirsaman and Badam, Anirudh and Phanishayee, Amar and Zhou, Yanqi and Alagappan, Ramnatthan and Strauss, Karin and Swanson, Steven},
  booktitle={Proceedings of the Twelfth European Conference on Computer Systems},
  pages={499--512},
  year={2017},
  organization={ACM},
  address={Belgrade, Serbia}
}
```

### Object-Oriented recovery
* problem: object-oriented programs, in recovery, may run into issues:
    * transient fields (like pointers to temporal resources) may not be valid
      any more
    * address invalidation due to address randomization, for read-only fields,
      libraries and v-tables.
    * code/library/os upgrade across executions 
* key idea: compiler support.
    * keep the nv-heap layout and relocate all (traditional, not fat or smart)
      pointers based on the difference between old and new base (virtual)
      address. Can be done lazily.
    * require and run custom re-constructor function at recover time.
* note:
    * only support access from single process.
```bibtex
@article{cohen-oopsla-2018,
  title={Object-oriented recovery for non-volatile memory},
  author={Cohen, Nachshon and Aksun, David T and Larus, James R},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={OOPSLA},
  pages={153},
  year={2018},
  publisher={ACM},
  address={Boston, MA, USA}
}
```

### PPTR
```bibtex
@inproceedings{chen-micro-2017,
 author         = {Chen, Guoyang 
                and Zhang, Lei 
                and Budhiraja, Richa 
                and Shen, Xipeng 
                and Wu, Youfeng},
 title          = {Efficient Support of Position Independence on Non-volatile Memory},
 booktitle      = {50th IEEE/ACM Intl. Symp. on Microarchitecture (MICRO)},
 year           = {2017},
 month          = oct,
 isbn           = {978-1-4503-4952-9},
 address        = {Cambridge, MA},
 pages          = {191--203},
 numpages       = {13},
 url            = {http://doi.acm.org/10.1145/3123939.3124543},
 doi            = {10.1145/3123939.3124543},
 acmid          = {3124543},
}
```

### NV-Heaps:
* A compresensive object-based NVM programming system including strong typing,
  reference-counting-based automatic memory management, undo-logging based ACID
  transactions.
* Details:
  * Requirements: mmap() function provided by the file system, and epoch
    barriers which waits all previous writs to be flushed to persistent memory.
  * Allocator:
    * failure atomicity: uses non-volatile redo-log based operation descriptors,
      one per kind of operation (allocation, delete, ...) for each thread.
    * concurrency: one lock per reference counter on each object; use generation
      lock to unlock all locks in the previous era.
    * allocation: per-thread free lists and global free lists
    * deallocation: for recursive deallocation caused by reduced reference
      counters, use "root deletion" and "non-root deletion" descriptors to mark
      the beginning and end of the chain. On recovery, start with the end
      (non-root) of the chain and begin again with the beginning (root).
    * caveat: destruction may be called twice on recovery.
  * Pointers:
    * NV-to-NV: "strong" pointers count as reference counts; "weak" ones don't
      to avoid memory leaks. "Weak" pointers need to be set null when the target
      is retired, implemented with proxy nodes.
    * V-to-NV: add a second non-volatile V-to-VN reference counter into each
      object so those pointers can also keep the objects alive.
  * Transactions:
    * undo logging that copies the whole (original) object upon opening for write
```bibtex
@inproceedings{coburn-asplos-2011,
 author = {Coburn, Joel and Caulfield, Adrian M. and Akel, Ameen and Grupp, Laura M. and Gupta, Rajesh K. and Jhala, Ranjit and Swanson, Steven},
 title = {NV-Heaps: Making Persistent Objects Fast and Safe with Next-generation, Non-volatile Memories},
 booktitle = {Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS XVI},
 year = {2011},
 address = {Newport Beach, California, USA},
 pages = {105--118},
 numpages = {14},
 doi = {10.1145/1950365.1950380},
}
```

### NVThreads
* Details:
  * Transforming threads to processes to have per-thread private logs.
  * Durability point: when the _logs_ are flushed, rather than the actual data
    is merged.
  * Stores to NVM are recorded in the per-thread copy-on-write page diffs as
    redo logs before (which requires a fence) they are written back to the
    actual shared data
  * Log truncation need stop-the-world quiescence, where all cache entries
    affected by to-be-truncated dirty pages will be flushed.
* Advantage over Atlas:
  * Got rid of compiler support
  * better support for condition variables for wait and signal calls (without
    replacing them with locks)
  * simpler recovery: single `bool crashed()` call versus iterating through each
    persistent region.
```bibtex
@inproceedings{hsu-eurosys-2017,
  title={NVthreads: Practical persistence for multi-threaded applications},
  author={Hsu, Terry Ching-Hsiang and Br{\"u}gner, Helge and Roy, Indrajit and Keeton, Kimberly and Eugster, Patrick},
  booktitle={Proceedings of the Twelfth European Conference on Computer Systems},
  pages={468--482},
  year={2017},
  organization={ACM},
  address={Belgrade, Serbia}
}
```

### REWIND
```bibtex
@article{chatzistergiou-vldb-2015,
 author = {Chatzistergiou, Andreas and Cintra, Marcelo and Viglas, Stratis D.},
 title = {REWIND: \≪U\≫Re\≪/U\≫Covery \≪U\≫W\≪/U\≫Rite-ahead System for \≪U\≫I\≪/U\≫N-memory \≪U\≫N\≪/U\≫On-volatile \≪U\≫D\≪/U\≫Ata-structures},
 journal = {Proc. VLDB Endow.},
 issue_date = {January 2015},
 volume = {8},
 number = {5},
 month = jan,
 year = {2015},
 pages = {497--508},
 numpages = {12},
 publisher = {VLDB Endowment},
}
```

### persist JVM state
```bibtex
@inproceedings{suezawa-java-2000,
  title={Persistent execution state of a Java virtual machine},
  author={Suezawa, Takashi},
  booktitle={Proceedings of the ACM 2000 conference on Java Grande},
  pages={160--167},
  year={2000},
  organization={Citeseer},
  address={San Francisco, California, USA}
}
```

### Sumatra: language that does thread serialization
```bibtex
@inproceedings{acharya-mos-1996,
  title={Sumatra: A language for resource-aware mobile programs},
  author={Acharya, Anurag and Ranganathan, Mudumbai and Saltz, Joel},
  booktitle={International Workshop on Mobile Object Systems},
  pages={111--130},
  year={1996},
  organization={Springer},
  address={Linz, Austria}
}
```

## Persistent data structures

### Dali (*)
```bibtex
@inproceedings{nawab-disc-2017,
 author         = {Faisal Nawab 
                and Joseph Izraelevitz 
                and Terence Kelly 
                and Charles B. Morrey III 
                and Dhruva R. Chakrabarti 
                and Michael L. Scott},
 title          = {{Dal{\'i}: A Periodically Persistent Hash Map}},
 booktitle      = {Intl. Symp. on Distributed Computing (DISC)},
 pages          = {37:1--37:16},
 year           = {2017},
 month          = oct,
 volume         = {91},
 address        = {Vienna, Austria},
}
```

### Persistent queue
```bibtex
@inproceedings{friedman-ppopp-2018,
 author = {Friedman, Michal and Herlihy, Maurice and Marathe, Virendra and Petrank, Erez},
 title = {A Persistent Lock-free Queue for Non-volatile Memory},
 booktitle = {Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
 year = {2018},
 pages = {28--40},
 numpages = {13},
 address = {Vienna, Austria}
} 
```

### persistent lock-free data structures
```bibtex
@article{attiya-2019,
  title={Tracking in Order to Recover: Recoverable Lock-Free Data Structures},
  author={Attiya, Hagit and Ben-Baruch, Ohad and Fatourou, Panagiota and Hendler, Danny and Kosmas, Eleftherios},
  journal={arXiv preprint arXiv:1905.13600},
  year={2019}
}
```

### persistent sets
```bibtex
@article{zuriel-oopsla-2019,
 author = {Zuriel, Yoav and Friedman, Michal and Sheffi, Gali and Cohen, Nachshon and Petrank, Erez},
 title = {Efficient Lock-free Durable Sets},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {October 2019},
 volume = {3},
 number = {OOPSLA},
 month = oct,
 year = {2019},
 articleno = {128},
 numpages = {26},
 publisher = {ACM},
 address = {Athens, Greece},
}
```

### Log-free persistent data structures
```bibtex
@inproceedings {david-atc-2018,
author = {Tudor David and Aleksandar Dragojevi{\'c} and Rachid Guerraoui and Igor Zablotchi},
title = {Log-Free Concurrent Data Structures},
booktitle = {2018 {USENIX} Annual Technical Conference ({USENIX} {ATC} 18)},
year = {2018},
isbn = {978-1-939133-01-4},
address = {Boston, MA},
pages = {373--386},
url = {https://www.usenix.org/conference/atc18/presentation/david},
publisher = {{USENIX} Association},
month = jul,
}
```

### persistent data structures
```bibtex
@article{mahapatra-2019,
  title={Don't Persist All: Efficient Persistent Data Structures},
  author={Mahapatra, Pratyush and Hill, Mark D and Swift, Michael M},
  journal={arXiv preprint arXiv:1905.13011},
  year={2019}
}
```

### Pronto: Easy and Fast Persistence for Volatile Data Structures
WARNING: page number and page count to be added

This paper shares (almost exactly) the key idea of our proposed durable data
structure: keeping the abstraction persistent but the data structure transient.
They did so by leveraging the fact that for each operation, the updates to the
abstraction lies completely in operation _arguments_: one only need to log the
arguments of each operation in order to rebuild (at least parts of) the data
structure. The log is called asynchronous semantic log (ASL) To avoid having an
infinitively long log of arguments, they bundled a new thread to each existing
thread to take periodic snapshots of their online (transient) image, an only
replay the ASL since the last snapshot after crashes.

```bibtex
@inproceedings{memaripour-asplos-2020,
 author = {Memaripour, Amirsaman and Izraelevitz, Joseph and Swanson, Steven},
 title = {Pronto: Easy and Fast Persistence for Volatile Data Structures},
 booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '20},
 pages = {789-806},
 year = {2020},
 address = {Lausanne, Switzerland},
 publisher = {ACM},
} 
```

### MOD: Minimally ordered durable data structures

```bibtex
@inproceedings{haria-asplos-2020,
    author = {Haria, Swapnil and Hill, Mark D. and Swift, Michael M.},
    title = {MOD: Minimally Ordered Durable Datastructures for Persistent Memory},
    year = {2020},
    booktitle = {Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems},
    pages = {775–788},
    numpages = {14},
    keywords = {persistent memory., durability, crash-consistency, datastructures},
    address = {Lausanne, Switzerland},
	series = {ASPLOS ’20}
}
```



## Porting existing code

### NVMOVE:
```bibtex
@inproceedings{chauhan-inflow-2016,
  title={NVMOVE: Helping Programmers Move to Byte-Based Persistence},
  author={Chauhan, Himanshu and Calciu, Irina and Chidambaram, Vijay and Schkufza, Eric and Mutlu, Onur and Subrahmanyam, Pratap},
  booktitle={4th Workshop on Interactions of NVM/Flash with Operating Systems and Workloads (INFLOW 16)},
  year={2016},
  address={Savannah, GA, USA}
}
```

### Breeze
```bibtex
@inproceedings{memaripour-iccd-2018,
  title={Breeze: User-Level Access to Non-Volatile Main Memories for Legacy Software},
  author={Memaripour, Amirsaman and Swanson, Steven},
  booktitle={2018 IEEE 36th International Conference on Computer Design (ICCD)},
  pages={413--422},
  year={2018},
  organization={IEEE},
  address={Orlando, Florida, USA}
}
```

## Managed language support

### Espresso -- Java extension for NVM
```bibtex
@inproceedings{wu-asplos-2018,
 author = {Wu, Mingyu and Zhao, Ziming and Li, Haoyu and Li, Heting and Chen, Haibo and Zang, Binyu and Guan, Haibing},
 title = {Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory},
 booktitle = {Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '18},
 year = {2018},
 address = {Williamsburg, VA, USA},
 pages = {70--83},
 numpages = {14},
 publisher = {ACM},
} 
```

### JSNVM -- javascript extension for NVM
```bibtex
@inproceedings{xu-icpads-2018,
  title={JSNVM: Supporting Data Persistence in JavaScript Using Non-Volatile Memory},
  author={Xu, Hao and Zhu, Yanmin and Chen, Yuting and Hunag, Linpeng and Li, Tianyou and Deng, Pan},
  booktitle={2018 IEEE 24th International Conference on Parallel and Distributed Systems (ICPADS)},
  pages={457--464},
  year={2018},
  organization={IEEE},
  address={Sentosa, Singapore}
}
```

# NVM Storage & file systems:

## File systems:

### BPFS

* assumption: only 8iB words can be written to the NVM atomically
* keeping multiple "epochs" on-the-fly, since flushing to NVM goes all the way to the capacitor on NVM, which is expensive

```bibtex
@inproceedings{10.1145/1629575.1629589,
    author = {Condit, Jeremy and Nightingale, Edmund B. and Frost, Christopher and Ipek, Engin and Lee, Benjamin and Burger, Doug and Coetzee, Derrick},
    title = {Better I/O through Byte-Addressable, Persistent Memory},
    year = {2009},
    isbn = {9781605587523},
    publisher = {Association for Computing Machinery},
    url = {https://doi.org/10.1145/1629575.1629589},
    doi = {10.1145/1629575.1629589},
    booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
    pages = {133–146},
    numpages = {14},
    keywords = {phase change memory, file systems, performance},
    address = {Big Sky, Montana, USA},
    series = {SOSP ’09}
}
  

```



### NOVA file system

```bibtex
@inproceedings{xu-fast-2016,
  title={NOVA: A Log-structured File System for Hybrid Volatile/Non-volatile Main Memories},
  author={Xu, Jian and Swanson, Steven},
  booktitle={14th USENIX Conference on File and Storage Technologies (FAST 16)},
  pages={323--338},
  year={2016},
  address={Santa Clara, CA}
}
```

### NOVA-fortis
```bibtex
@inproceedings{xu-sosp-2017,
  title={NOVA-Fortis: A fault-tolerant non-volatile main memory file system},
  author={Xu, Jian and Zhang, Lu and Memaripour, Amirsaman and Gangadharaiah, Akshatha and Borase, Amit and Da Silva, Tamires Brito and Swanson, Steven and Rudoff, Andy},
  booktitle={Proceedings of the 26th Symposium on Operating Systems Principles},
  pages={478--496},
  year={2017},
  organization={ACM},
  address={Shanghai, China}
}
```

## Data Serialization

### Performance survey of serialization libraries
```bibtex
@inproceedings{maeda-dictap-2012,
  title={Performance evaluation of object serialization libraries in XML, JSON and binary formats},
  author={Maeda, Kazuaki},
  booktitle={2012 Second International Conference on Digital Information and Communication Technology and it's Applications (DICTAP)},
  pages={177--182},
  year={2012},
  organization={IEEE},
  address={Bangkok, Thailand}
}
```

### Performance survey of serialization libraries on Android JVM
```bibtex
@inproceedings{sumaray-icuimc-2012,
  title={A comparison of data serialization formats for optimal efficiency on a mobile platform},
  author={Sumaray, Audie and Makki, S Kami},
  booktitle={Proceedings of the 6th international conference on ubiquitous information management and communication},
  pages={48},
  year={2012},
  organization={ACM},
  address={Kuala Lumpur, Malaysia}
}
```

### XML-based object serialization
* key idea: use compiler support to automatically generate serialization
  routines for C and C++ data types.
```bibtex
@article{van-cpc-2006,
  title={Toward remote object coherence with compiled object serialization for distributed computing with xml web services},
  author={Van Engelen, Robert and Zhang, Wei and Govindaraju, Madhusudhan},
  journal={in the proceedings of Compilers for Parallel Computing (CPC)},
  pages={441--455},
  year={2006},
  address={New Orleans, Louisiana, USA}
}
```

### Binary XML serialization formats interchangable with text-based XML
```bibtex
@inproceedings{kangasharju-socp-2007,
 author = {Kangasharju, Jaakko and Tarkoma, Sasu},
 title = {Benefits of Alternate XML Serialization Formats in Scientific Computing},
 booktitle = {Proceedings of the 2007 Workshop on Service-oriented Computing Performance: Aspects, Issues, and Approaches},
 series = {SOCP '07},
 year = {2007},
 address = {Monterey, California, USA},
 pages = {23--30},
 numpages = {8},
 publisher = {ACM},
}
```

### In-depth analysis of the drawbacks of object serialization
* The "inhale" and "exhale" effect brings significant overhead sourced from
  serialization/deserialization.
* "Orthogonal persistency" can be one alternative approach: instead of making
  all persistent classes inherit from a "persistent" class, all objects
  reachable from persistent root are considered persistent. Reflection is needed
  in this case of course.
```bibtex
@article{evans-tr-2000,
  title={Why object serialization is inappropriate for providing persistence in java},
  author={Evans, Huw},
  journal={Department of Computer Science, The University of Glasgow},
  year={2000}
}
```

### Java object serialization (built-in)
```bibtex
@inproceedings{opyrchal-workshop-1999,
  title={Efficient object serialization in Java},
  author={Opyrchal, Lukasz and Prakash, Atul},
  booktitle={Proceedings. 19th IEEE International Conference on Distributed Computing Systems. Workshops on Electronic Commerce and Web-based Applications. Middleware},
  pages={96--101},
  year={1999},
  organization={IEEE}
}
```

### Java thread serialization
```bibtex
@inproceedings{bouchenak-aiccsa-2003,
  title={Techniques for implementing efficient java thread serialization},
  author={Bouchenak, Sara and Hagimont, Daniel and De Palma, No{\"e}l},
  booktitle={ACS/IEEE International Conference on Computer Systems and Applications (AICCSA’03)},
  pages={14--18},
  year={2003},
  organization={Citeseer},
  address={Tunis, Tunisia}
}
```

### Python pickling in MPI
```bibtex
@article{dalcin-journal-2008,
  title={MPI for Python: Performance improvements and MPI-2 extensions},
  author={Dalc{\'\i}n, Lisandro and Paz, Rodrigo and Storti, Mario and D’El{\'\i}a, Jorge},
  journal={Journal of Parallel and Distributed Computing},
  volume={68},
  number={5},
  pages={655--662},
  year={2008},
  publisher={Elsevier}
}
```

### fast object-oriented pickles (serialization)
* With compiler help, generate static pickling functions at compile time as much as possible.
* Unlike Java serializer that only serialize to language-specific format, it can work with arbitrary pickle (serialize) format.
```bibtex
@inproceedings{miller-oopsla-2013,
 author = {Miller, Heather and Haller, Philipp and Burmako, Eugene and Odersky, Martin},
 title = {Instant Pickles: Generating Object-oriented Pickler Combinators for Fast and Extensible Serialization},
 booktitle = {Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages \&\#38; Applications},
 series = {OOPSLA '13},
 year = {2013},
 address = {Indianapolis, Indiana, USA},
 pages = {183--202},
 numpages = {20},
 publisher = {ACM},
}
```

### ML pickler combinator
```bibtex
@inproceedings{elsman-journal-2005,
  title={Type-specialized serialization with sharing.},
  author={Elsman, Martin},
  booktitle={Trends in Functional Programming},
  pages={47--62},
  year={2005}
}
```

### Perl pickler combinator
```bibtex
@article{kennedy-journal-2004,
  title={Functional pearl pickler combinators},
  author={Kennedy, Andrew J},
  journal={Journal of Functional Programming},
  volume={14},
  number={6},
  pages={727--739},
  year={2004},
  publisher={Cambridge University Press}
}
```

### OCaml and pickler combinator
```bibtex
@inproceedings{yallop-ml-2007,
  title={Practical generic programming in OCaml},
  author={Yallop, Jeremy},
  booktitle={Proceedings of the 2007 Workshop on ML},
  pages={83--94},
  year={2007},
  organization={ACM},
  location={Freiburg, Germany}
}
```
### static meta programming
```bibtex
@article{skalski-thesis-2005,
  title={Syntax-extending and type-reflecting macros in an object-oriented language},
  author={Skalski, Kamil},
  journal={Master's thesis, University of Warsaw, Poland},
  year={2005}
}
```

### SOAP
```bibtex
@misc{w3c-soap,
  title={SOAP 1.1 and 1.2 specifications},
  author={W3C},
  note={www.w3c.org}
}
```

### WSDL
```bibtex
@misc{christensen-wsdl-2001,
  title={Web services description language (WSDL) 1.1},
  author={Christensen, Erik and Curbera, Francisco and Meredith, Greg and Weerawarana, Sanjiva and others},
  year={2001},
  publisher={Citeseer}
}
```

### Java Jackson library (auto serialization)
```bibtex
@misc{java-jackson,
  title={Jackson Project},
  author={FasterXML, LLC},
  note={github.com/FasterXML/jackson}
}
```

## IDL:

### Corba IDL
```bibtex
@article{sivaprasad-1995,
  title={Larch/CORBA: Specifying the behavior of CORBA-IDL interfaces},
  author={Sivaprasad, Sankar Gowri},
  year={1995}
}
```

### Corba object computing
```bibtex
@article{vinoski-1993,
  title={Distributed object computing with CORBA},
  author={Vinoski, Steve},
  journal={C++ Report},
  volume={5},
  number={6},
  pages={32--38},
  year={1993}
}
```

### Extension of IDL for testing
```bibtex
@inproceedings{sankar-idl-1994,
 author = {Sankar, Sriram and Hayes, Roger},
 title = {ADL\&Mdash;an Interface Definition Language for Specifying and Testing Software},
 booktitle = {Proceedings of the Workshop on Interface Definition Languages},
 series = {IDL '94},
 year = {1994},
 address = {Portland, Oregon, USA},
 pages = {13--21},
 numpages = {9},
 publisher = {ACM},
} 
```

### Protocol specifications
```bibtex
@article{yellin-toplas-1997,
  title={Protocol specifications and component adaptors},
  author={Yellin, Daniel M and Strom, Robert E},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={19},
  number={2},
  pages={292--333},
  year={1997},
  publisher={ACM}
}
```

### Extending CORBA with protocols
```bibtex
@article{canal-journal-2001,
  title={Extending CORBA interfaces with protocols},
  author={Canal, Carlos and Fuentes, Lidia and Pimentel, Ernesto and Troya, Jos{\'e} M and Vallecillo, Antonio},
  journal={The Computer Journal},
  volume={44},
  number={5},
  pages={448--462},
  year={2001},
  publisher={Oxford University Press}
}
```

### Adding semantics to IDL
```bibtex
@inproceedings{watkins-1998,
  title={Adding semantics to interface definition languages},
  author={Watkins, Damien and Thompson, Dean},
  booktitle={Proceedings 1998 Australian Software Engineering Conference (Cat. No. 98EX233)},
  pages={66--78},
  year={1998},
  organization={IEEE},
  addresss={Adelaide, Australia}
}
```

### Path Expressions
```bibtex
@inproceedings{watkins-tools-1998,
  title={Using interface definition languages to support path expressions and programming by contract},
  author={Watkins, Damien},
  booktitle={Proceedings. Technology of Object-Oriented Languages. TOOLS 26 (Cat. No. 98EX176)},
  pages={308--317},
  year={1998},
  organization={IEEE}
}
```

## .Net:

### .Net in general
```bibtex
@article{meyer-journal-2001,
  title={. NET is coming [Microsoft Web services platform]},
  author={Meyer, Bertrand},
  journal={Computer},
  volume={34},
  number={8},
  pages={92--97},
  year={2001},
  publisher={IEEE},
  address={Melbourne, Australia}
}
```

### .Net CLR
```bibtex
@inproceedings{kennedy-pldi-2001,
 author = {Kennedy, Andrew and Syme, Don},
 title = {Design and Implementation of Generics for the .NET Common Language Runtime},
 booktitle = {Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation},
 series = {PLDI '01},
 year = {2001},
 address = {Snowbird, Utah, USA},
 pages = {1--12},
 numpages = {12},
 publisher = {ACM},
} 
```

## Utils:

### Failure-Atomic Slotted Paging
```bibtex
@inproceedings{seo-asplos-2017,
 author = {Seo, Jihye and Kim, Wook-Hee and Baek, Woongki and Nam, Beomseok and Noh, Sam H.},
 title = {Failure-Atomic Slotted Paging for Persistent Memory},
 booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '17},
 year = {2017},
 address = {Xi'an, China},
 pages = {91--104},
 numpages = {14},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
```

# Data interchange:

## Data interchange files

### Mison: A Fast JSON Parser for Data Analytics
* Basic idea: push down both projections and filters into the parser
  * Observations:
    * some applications query only a (small) part of the fields
    * records tend to have similar logical structure
  * Approach:
    * using a small portion of data as training set, Mison speculatively predicts the _logical locations_ of queried field
    * during parsing, Mison builds the _structural locations_ of each field and map it with logical locations.
```bibtex
@article{li-vldb-2017,
  title={Mison: a fast JSON parser for data analytics},
  author={Li, Yinan and Katsipoulakis, Nikos R and Chandramouli, Badrish and Goldstein, Jonathan and Kossmann, Donald},
  journal={Proceedings of the VLDB Endowment},
  volume={10},
  number={10},
  pages={1118--1129},
  year={2017},
  publisher={VLDB Endowment}
}
```

### Filter before you parse: Faster analytics on raw data with sparser
* Basic idea: raw filtering. Filter data before parsing
  * Before parsing is done, do pattern matching on raw data to decide whether to continue parsing.
  * Some optimizations on lowering false positive rate.
```bibtex
@article{palkar-vldb-2018,
  title={Filter before you parse: Faster analytics on raw data with sparser},
  author={Palkar, Shoumik and Abuzaid, Firas and Bailis, Peter and Zaharia, Matei},
  journal={Proceedings of the VLDB Endowment},
  volume={11},
  number={11},
  pages={1576--1589},
  year={2018},
  publisher={VLDB Endowment}
}
```

## Protocol buffer-related

### Cap'n proto
```bibtex
@misc{capnproto,
  title={Cap'n Proto: a fast data interchange format},
  author={Kenton Varda},
  note={\url{capnproto.org}}
}
```

### Protocol Buffers
```bibtex
@misc{protobuf,
  title={Protocol Buffers: language-neutral, platform-neutral, extensible mechanism for serializing structured data },
  author={Google},
  note={\url{developers.google.com/protocol-buffers}}
}
```

### Boost serialization lib
```bibtex
@misc{boost-serialization,
  title={Boost Serialization Library},
  note={\url{www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html}}
}
```

### FlatBuffers
```bibtex
@misc{flatbuffers,
  title={FlatBuffers},
  note={\url{google.github.io/flatbuffers/}}
}
```

### Interweave
```bibtex
@inproceedings{chen-lcr-2000,
  title={Interweave: A middleware system for distributed shared state},
  author={Chen, DeQing and Dwarkadas, Sandhya and Parthasarathy, Srinivasan and Pinheiro, Eduardo and Scott, Michael L},
  booktitle={International Workshop on Languages, Compilers, and Run-Time Systems for Scalable Computers},
  pages={207--220},
  year={2000},
  organization={Springer},
  address={Rochester, NY, USA}
}
```



# NVM driving applications & in-memory databases:

### Godot game engine
```bibtex
@misc{godot,
  title={Godot Game Engine},
  note={\url{godotengine.org}}
}
```
### RocksDB
```bibtex
@misc{rocksdb,
  title={RocksDB},
  note={\url{rocksdb.org}}
}
```
### NVM as cache in RocksDB
```bibtex
@inproceedings{eisenman-eurosys-2018,
 author = {Eisenman, Assaf and Gardner, Darryl and AbdelRahman, Islam and Axboe, Jens and Dong, Siying and Hazelwood, Kim and Petersen, Chris and Cidon, Asaf and Katti, Sachin},
 title = {Reducing DRAM Footprint with NVM in Facebook},
 booktitle = {Proceedings of the Thirteenth EuroSys Conference},
 series = {EuroSys '18},
 year = {2018},
 address = {Porto, Portugal},
 pages = {42:1--42:13},
 numpages = {13},
 publisher = {ACM},
}
```
### Persistent memory region layout in RocksDB
```bibtex
@misc{li-nvmrocks-2017,
  title={NVMRocks: RocksDB on Non-Volatile Memory Systems},
  author={ Jianhong Li, Andrew Pavlo, Siying Dong},
  note={istc-bigdata.org/index.php/nvmrocks-rocksdb-on-non-volatile-memory-systems/}
}
```

### Redis
```bibtex
@misc{redis,
  title={Redis},
  note={redis.io}
}
```

# Other papers about NVM/persistency

### whole-system persistence:
```bibtex
@inproceedings{narayanan-asplos-2012,
 author = {Narayanan, Dushyanth and Hodson, Orion},
 title = {Whole-system Persistence},
 booktitle = {Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS XVII},
 year = {2012},
 address = {London, England, UK},
 pages = {401--410},
 numpages = {10},
 publisher = {ACM},
} 
```

# Protected Libraries:

### Hodor (*)
```bibtex
@inproceedings{hedayati-atc-2019,
  author = {Mohammad Hedayati and Spyridoula Gravani and Ethan Johnson and John Criswell and Michael L. Scott and Kai Shen and Mike Marty},
  title = {Hodor: Intra-Process Isolation for High-Throughput Data Plane Libraries},
  booktitle = {2019 USENIX Annual Technical Conference (ATC' 19)},
  year = {2019},
  address = {Renton, WA},
  pages = {489--504},
  publisher = {USENIX Association}
}
```

### Janus (*)
```bibtex
@techreport{hedayati-tr-2018,
  title={Janus: Intra-process isolation for high-throughput data plane libraries},
  author={Hedayati, Mohammad and Gravani, Spyridoula and Johnson, Ethan and Criswell, John and Scott, Michael and Shen, Kai and Marty, Mike},
  year={2018},
  institution={Technical Report UR CSD/1004}
}
```

### Arrakis
```bibtex
@inproceedings{peter-osdi-2013,
  title={Arrakis: The operating system is the control plane},
  author={Peter, Simon and Li, Jialin and Zhang, Irene and Ports, Dan RK and Krishnamurthy, Arvind and Anderson, Thomas and Roscoe, Timothy},
  booktitle={Proc. 11th USENIX Conf. Oper. Syst. Des. Implement},
  volume={38},
  number={4},
  pages={44--47},
  year={2013},
  address={Broomfield, CO, USA}
}
```
### ZygOS
```bibtex
@inproceedings{prekas-sosp-2017,
  title={Zygos: Achieving low tail latency for microsecond-scale networked tasks},
  author={Prekas, George and Kogias, Marios and Bugnion, Edouard},
  booktitle={Proceedings of the 26th Symposium on Operating Systems Principles},
  pages={325--341},
  year={2017},
  organization={ACM},
  address={Shanghai, China}
}
```

### Demikernel
```bibtex
@inproceedings{zhang-hotos-2019,
  title={I'm Not Dead Yet!: The Role of the Operating System in a Kernel-Bypass Era},
  author={Zhang, Irene and Liu, Jing and Austin, Amanda and Roberts, Michael Lowell and Badam, Anirudh},
  booktitle={Proceedings of the Workshop on Hot Topics in Operating Systems},
  pages={73--80},
  year={2019},
  organization={ACM},
  address={Bertinoro, Italy}
}
```

# POMCAS related works

### RSTM
```bibtex
@INPROCEEDINGS{marathe-transact-2006,
    AUTHOR      = {Virendra J. Marathe and Michael F. Spear and
                  Christopher Heriot and Athul Acharya and David
                  Eisenstat and William N. Scherer{ }III and Michael
                  L. Scott},
    TITLE       = {Lowering the Overhead of Software Transactional
                  Memory},
    BOOKTITLE   = {First ACM SIGPLAN Workshop on Transactional
                  Computing (TRANSACT)},
    MONTH       = {jun},
    YEAR        = {2006},
    ADDRESS     = {Ottawa, ON, Canada},
    NOTE        = {Expanded version available as TR 893, Univ. of
                  Rochester Computer Science Dept., Mar. 2006},
}
```

### DSTM
```bibtex
@inproceedings{herlihy-podc-2003,
author = {Herlihy, Maurice and Luchangco, Victor and Moir, Mark and Scherer, William N.},
title = {Software Transactional Memory for Dynamic-Sized Data Structures},
year = {2003},
publisher = {Association for Computing Machinery},
booktitle = {Proceedings of the Twenty-Second Annual Symposium on Principles of Distributed Computing},
pages = {92–101},
numpages = {10},
address = {Boston, Massachusetts},
series = {PODC ’03}
}
```

### Polka
```bibtex
@inproceedings{scherer-podc-2005,
author = {Scherer, William N. and Scott, Michael L.},
title = {Advanced Contention Management for Dynamic Software Transactional Memory},
year = {2005},
isbn = {1581139942},
publisher = {Association for Computing Machinery},
booktitle = {Proceedings of the Twenty-Fourth Annual ACM Symposium on Principles of Distributed Computing},
pages = {240–248},
numpages = {9},
keywords = {obstruction-freedom, synchronization, transactional memory, contention management},
address = {Las Vegas, NV, USA},
series = {PODC ’05}
}
```