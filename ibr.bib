# IBR-related works 
(to be put in a seperate file)

### IBR (*)
```bibtex
@inproceedings{wen-ppopp-2018,
 author = {Wen, Haosen and Izraelevitz, Joseph and Cai, Wentao and Beadle, H. Alan and Scott, Michael L.},
 title = {Interval-based Memory Reclamation},
 booktitle = {Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
 series = {PPoPP '18},
 year = {2018},
 address = {Vienna, Austria},
 pages = {1--13},
 numpages = {13},
 publisher = {ACM},
} 
```

### epoch-based reclamation
```bibtex
@article{hart-jpdc-2007,
  author =        {Hart, Thomas E. and McKenney, Paul E. and
                   Brown, Angela Demke and Walpole, Jonathan},
  journal =       {Journal of {Parallel} and {Distributed} {Computing}},
  month =         dec,
  number =        {12},
  pages =         {1270--1285},
  publisher =     {Academic Press, Inc.},
  title =         {Performance of Memory Reclamation for Lockless
                   Synchronization},
  volume =        {67},
  year =          {2007},
}
```

```bibtex
@phdthesis{fraser-thesis-2004,
  author =        {Fraser, Keir},
  note =          {No. UCAM-CL-TR-579},
  school =        {Computer Laboratory, University of Cambridge},
  title =         {Practical lock-freedom},
  year =          {2004},
  month =         feb,
}
```

### robustness
```bibtex
@inproceedings{dice-ismm-2016,
  author =        {Dice, Dave and Herlihy, Maurice and Kogan, Alex},
  booktitle =     {Proc. of the 2016 ACM SIGPLAN Intl.
                   Symp. on Memory Management},
  address =       {Santa Barbara, CA, USA},
  pages =         {36--45},
  series =        {ISMM '16},
  title =         {Fast Non-intrusive Memory Reclamation for
                   Highly-concurrent Data Structures},
  year =          {2016},
  month =         jun,
}
```

### hazard pointers
```bibtex
@article{michael-tpds-2004,
  author =        {Maged M. Michael},
  journal =       {IEEE Trans. on Parallel and Distributed Systems},
  month =         aug,
  number =        {8},
  pages =         {491-504},
  title =         {Hazard Pointers: Safe Memory Reclamation for
                   Lock-Free Objects},
  volume =        {15},
  year =          {2004},
}
```

```bibtex
@article{herlihy-tocs-2005,
  author =        {Herlihy, Maurice and Luchangco, Victor and
                   Martin, Paul and Moir, Mark},
  journal =       {ACM Trans. on Computer Systems},
  month =         may,
  number =        {2},
  pages =         {146--196},
  title =         {Nonblocking Memory Management Support for
                   Dynamic-sized Data Structures},
  volume =        {23},
  year =          {2005},
}
```

### Hazard Eras
```bibtex
@inproceedings{ramalhete-spaa-2017,
  author =        {Ramalhete, Pedro and Correia, Andreia},
  booktitle =     {Proc. of the 29th ACM Symp. on Parallelism
                   in Algorithms and Architectures},
  address =       {Washington, DC, USA},
  pages =         {367--369},
  series =        {SPAA '17},
  title =         {Brief Announcement: Hazard Eras - Non-Blocking Memory
                   Reclamation},
  year =          {2017},
  month =         jul,
}
```


### QSense
```bibtex
@inproceedings{balmau-spaa-2016,
  author =        {Balmau, Oana and Guerraoui, Rachid and
                   Herlihy, Maurice and Zablotchi, Igor},
  booktitle =     {Proc. of the 28th ACM Symp. on Parallelism
                   in Algorithms and Architectures},
  address =       {Pacific Grove, CA, USA},
  pages =         {349--359},
  series =        {SPAA '16},
  title =         {Fast and Robust Memory Reclamation for Concurrent
                   Data Structures},
  year =          {2016},
  month =         jul,
}
```

### history-preserving persistency
```bibtex
@inproceedings{driscoll-stoc-1986,
  author =        {Driscoll, James R. and Sarnak, Neil and Sleator, Daniel D. and
                   Tarjan, Robert E.},
  booktitle =     {Proc. of the 18th Ann. ACM Symp. on Theory of Computing},
  address =       {Berkeley, CA, USA},
  pages =         {109--121},
  series =        {STOC '86},
  title =         {Making Data Structures Persistent},
  year =          {1986},
  month =         may,
}
```

### treiber stack
```bibtex
@techreport{treiber-tr-1986,
  author =        {R. Kent Treiber},
  institution =   {IBM Almaden Research Center},
  month =         apr,
  number =        {RJ 5118},
  title =         {Systems Programming: Coping with Parallelism},
  year =          {1986},
}
```

### Universal concurrency construction
```bibtex
@article{herlihy-toplas-1993,
  author =        {Herlihy, Maurice},
  journal =       {ACM Trans. on Programming Languages and Systems},
  month =         nov,
  number =        {5},
  pages =         {745--770},
  title =         {A Methodology for Implementing Highly Concurrent Data
                   Objects},
  volume =        {15},
  year =          {1993},
}
```

### Functional data structures
```bibtex
@book{okasaki-book-1999,
  author =        {Okasaki, Chris},
  publisher =     {Cambridge University Press},
  title =         {Purely functional data structures},
  year =          {1999},
  month =         jun,
}
```

### Harris ordered list
```bibtex
@inproceedings{harris-disc-2001,
 author = {Harris, Timothy L.},
 title = {A Pragmatic Implementation of Non-blocking Linked-Lists},
 booktitle = {Proceedings of the 15th International Conference on Distributed Computing},
 series = {DISC '01},
 year = {2001},
 isbn = {3-540-42605-1},
 pages = {300--314},
 numpages = {15},
 url = {http://dl.acm.org.ezp.lib.rochester.edu/citation.cfm?id=645958.676105},
 acmid = {676105},
 publisher = {Springer-Verlag},
 address = {Lisbon, Portugal},
	annote	= {
Introduction of the mark and remove method for concurrent queues.
	}
} 
```

### Michael's hash map
```bibtex
@inproceedings{michael-podc-1996,
 author = {Michael, Maged M. and Scott, Michael L.},
 title = {Simple, Fast, and Practical Non-blocking and Blocking Concurrent Queue Algorithms},
 booktitle = {Proceedings of the 1996 ACM Symposium on Principles of Distributed Computing},
 series = {PODC '96},
 year = {1996},
 address = {Philadelphia, Pennsylvania, USA},
 pages = {267--275},
 numpages = {9},
 publisher = {ACM},
	annote ={
The classic M and S (M&S) queue.
	}
} 
```

### Natarajan-Mittal's tree
```bibtex
@inproceedings{natarajan-ppopp-2014,
 author = {Natarajan, Aravind and Mittal, Neeraj},
 title = {Fast Concurrent Lock-free Binary Search Trees},
 booktitle = {Proceedings of the 19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
 series = {PPoPP '14},
 year = {2014},
 address = {Orlando, Florida, USA},
 pages = {317--328},
 numpages = {12},
 publisher = {ACM},
} 
```

### Bonsai Tree
```bibtex
@inproceedings{clements-asplos-2012,
 author = {Clements, Austin T. and Kaashoek, M. Frans and Zeldovich, Nickolai},
 title = {Scalable Address Spaces Using RCU Balanced Trees},
 booktitle = {Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS XVII},
 year = {2012},
 address = {London, England, UK},
 pages = {199--210},
 numpages = {12},
 publisher = {ACM},
 keywords = {RCU, concurrent balanced trees, lock-free algorithms, multicore, scalability, virtual memory},
} 
```

### Jemalloc
```bibtex
@inproceedings{evans-bsdcan-2006,
  title={A scalable concurrent malloc (3) implementation for FreeBSD},
  author={Evans, Jason},
  booktitle={Proceedings of the BSDCan Conference},
  year={2006},
	address = {Ottowa, Canada}
}
```


### NBR: Neutralization Based Reclamation
WARNING: page number and page count to be added
* goal: a fast and easy-to-use SMR method for nonblocking data structures
   * IBR-like methods won't easily work if application can traverse unlinked data
* Design of NBR:
   * NBR requires operations of applications to be organized in a 3-phase structure: read, reserve, and write.
      * Read: the operation can access all private or shared data, but cannot modify any shared data
      * Reserve: the operation publishes reservations of unreclaimable blocks in the following write, using information gathered in read phase
         * This can be seen as a part of read phase
      * Write: the operation modifies shared data if needed
   * Whenever a thread decides to reclaim stuff from its own limbo list (containing blocks already detached from shared structures) when it's "full", it sends a signal to all threads and start reclaiming. Upon receiving this signal:
      * threads in read phase or reserve phase jumps back to the beginning to its read phase, so the retry of read phase won't read anything from the limbo list
      * threads in write phase continues to execute to finish, while the reclaimer promises not to reclaim reserved blocks
* NBR+:
   * in (original) NBR, it takes O(n^2) signals for all threads to clear their limbo list once, which is expensive. A key observation is that when _some_ thread $T$ sends out signals, _every other_ thread _may_ have something reclaimable in its own limbo list, as all threads are having retries or reservations in respond to $T$'s signal.
   * NBR+ designs a protocol of _when_ such "hitchhiking" can (and should) happen, and _what_ can be reclaimed at such times:
      * When a thread's limbo list is "full" (or reaches some "high watermark"), it initiates a reclamation and updates a per-thread timestamp
      * When a thread's limbo list reaches some "low watermark", it records the current state of all threads' timestamp and the tail of its limbo list. Whenever it sees an update of someone's timestamp, it means blocks up to the tail in the limbo list (that are not reserved) can be reclaimed.
* k-NBR+:
   * When an operation of an application cannot be re-factored into a 3-phase structure, it can be divided into k NBR-friendly regions. The key point is between each region, all references of shared blocks must be discarded 
* Other notes:
   * At the beginning of read phase, NBR uses a CAS to change _restartable_ flag from false to true. Paper said it's for "preventing reordering", but I think maybe a store with acquire semantics would suffice. Similarly, the CAS at the end may be replaced with a store with release semantics.
   * Not sure why NBR+ uses a timestamp to catch reclamation events, since the reclamation initiator already sends signals to every other thread.

```bibtex
@inproceedings{singh-ppopp-2021,
 author={Singh, Ajay and Brown, Trevor and Mashtizadeh, Ali},
 title={NBR: Neutralization Based Reclamation},
 booktitle = {Proceedings of the 26th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
 series = {PPoPP '21},
 year = {2021},
 address = {virtual},
 publisher = {ACM},
}
```